https://getchan.github.io/cs/OS_1/#1-%EC%9A%B4%EC%98%81-%EC%B2%B4%EC%A0%9C%EC%9D%98-%EC%A0%95%EC%9D%98
^^^^^^^^^^함수 재귀  스택

<<<<< 운영체제(3)-인터럽트의 원리 >>>>>>>>

1.프로그램구조와 인터럽트

프로그램은 함수들로 구성된다. 함수 실행중에 다른 함수를 호출하고 호출된 함수의 수행이 끝나면 원래 함수로 돌아가 계속 수행하게 된다.
프로그램이 CPU에서 명령을 수행하려면 수행하려는 주소 영역이 메모리에 올라가있어야한다

프로그램의 주소영역은 세가지로 나눌 수 있다
 - 코드 : 프로그램 함수들의 코드가 기계어 명령으로 변환되어 저장되는 영역
 - 데이터 : 전역변수등 프로그램에 사용하는 데이터를 저장하는 여역
 - 스택 : 함수가 호출될 때 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는데 사용되는 영역 

인터럽트의 동작원리도 이와 유사하다
- a프로그램이 시피유를 할당받아 수행중에 인터럽트가발생
- 에이는 현재 수행중인 명령의 위치를  저장
- os 내부 인터럽트 처리 루틴으로 들어가 처리	
- a의 작업 지점부터 다시 처리 

일반적으로 프로그램 내애서 함수 호출이 필요한 복귀주소는 각 프로그램에 스택영역에 보관한다
반면 인터럽트때문에 시피유를 선점당해 저장하는 복귀 주소는 os 커널영역에 존재한다
이 주소를 저장하는 자료구조를 PCB라고 한다 process control block

2. 컴퓨터 시스템의 작동 개요
시피유가 수행해야할 메모리주소를 담고있는 레지스터릴 프로그램카운터 라고한다

컴퓨터 시스템 하드웨어
시피유
 - 일반명령: 모든 프로그램이 수행할 수 잇다
 - 특권명령 : 보안이 필요한 명령
 메모리 
  - 커널모드 : 피시가 운영체제가 존재하는 메모리를 가리키고있다
  - 유저모드 : 시피가 사용자 프로그램이 존재하는 메모리를 가리키고 있다
입출력장치
 - 입출력 컨트롤러 : 입출력장치에 있는 작은 시피유
 - 로컬버퍼 :입출력 컨트롤러에 있는 메모리? 
 
 사용자 프로그램이 특권명령의 수행을 필요로 한다면 운영체제에게 특권명령 대행을 요청한다 이를 시스템 콜 이라고한다.
 
 디스크에서 자료를 읽어오는 시스템 콜
 
 커널의 스택영역은 유저프로그램의 스택과 달ㄹ 현재 수행중인 프로세스마다 별도의 스택을 두어 관리한다.
 프로시스가 시스템 콜 후 시스템 콜 내부에서 다른 함수를 호출하는경우
 그 복귀주소는 커널 내의 주소가 되어 유저프로그램의 스택과는 별도의 저장공간이 필요하개됨
 커널은 일종의 공유코드이므로 일관성유지를 위해 각 프로세스마다 커널 내 별도의 스택이 필요함
 
 
 정리하자면!!!!!
 프로그램이 사용자 정의함수나 라이브러리함수를 호출할때는 사용자 모드에서 실행을 지속
 시스템 콜릉ㄹ 하는 경우 커널 모드로 진입해 커널의 주소공간에 정의된 함수를 실행한다
 시스템 콜이 끝나면 사용자 모드로 돌아와 이후 명령들을 계속 실행
 프로그램의 실행이 끝날때는 커널모드로 진입해 프로그램을 종료한다
 
 하드웨어 인터럽트가 발생한 경우에도 시피유의 제어권이 사용자모드에서 커널모드로 변경된다
시피유가 에이의 명령을 수행하는 중 이전에 비가 요청한 입출력이 완료되면
입출력 컨트롤러가 하드웨어 인터럽트를 발생
이러한 경우 커널모드 진입은 비를 위한것이지만 인터럽트가 처리되는 동안에 a의 문맥에서 실행되는것으로 간주한다
즉, a가 실행되던 중 인터럽트가 발생하면 발생원인가 관계없이 a가 사용자모드에서 커널모드로 진입한것으로 간주한다
 #옆에 이클립스 키고 하면 안되나? 물어봐야겠다
 
 
 프로세스란? 
 수행중인 프로그램
 프로그램이 메모리에 올라가서 수행하면 프로세스가 된다 
 
 <<<<< 운영체제(5)-인터럽트의 원리 >>>>>>>>
 
 라운드 로빈 스케줄링
각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간을 특정 시간(할당 시간, time quantum)으로 제한한다.

할당 시간이 경과하면 CPU를 회수해 준비 큐에 있는 다른 프로세스에게 CPU를 할당한다.

원래 프로세스는 준비 큐의 가장 뒤로 가서 다음 차례를 기다린다.

할당 시간이 너무 길면, FCFS알고리즘과 같아진다.

할당 시간이 너무 짧으면, CPU를 사용하는 프로세스가 빈번하게 교체되어 문맥 교환의 오버헤드가 증가한다.

n개의 프로세스가 준비 큐에 있고 할당 시간이 q라고 할 때, 모든 프로세스는 (n-1)q 시간 이내에 적어도 한번은 CPU를 할당받을 수 있다.

대화형 프로세스의 빠른 응답 시간을 보장한다.
CPU를 많이 쓰는 프로세스는 대기 시간이 길어지고

CPU를 적게 쓰는 프로세스는 대기 시간이 짧아진다.

SJF와 비교
일반적으로 SJF 방식보다 평균 대기 시간은 길지만, 응답 시간은 더 짧다.

CPU버스트 시간이 짧은 프로세스가 빨리 CPU를 얻을 수 있도록 하는 동시에, CPU 버스트가 긴 프로세스가 불이익을 당하지 않도록 한다.

FCFS와 비교
FCFS는 라운드 로빈보다 평균 대기 시간이나 평균 소요 시간 측면에서는 좋은 결과를 얻는다. 그러나, 프로세스 간 대기 시간이나 소요 시간의 편차가 매우 크며, 평균 응답 시간이 지나치게 길어지는 문제점이 있다.

라운드 로빈 스케줄링에서 할당 시간을 극단적으로 짧게 설정하면, 프로세스들이 거의 동시에 자신의 CPU 버스트를 끝마치게 된다. 따라서, 평균 응답 시간이 짧으며 대기 시간이나 처리 시간의 편차가 크지 않다. 그러나, 평균 대기 시간과 평균 소요 시간은 FCFS보다 비효율적이다.
	
 <<<<< 운영체제(6)-인터럽트의 원리 >>>>>>>>	
	
MMU는 논리적 주소를 물리적 주소로 매핑해주는 하드웨어 장치이다.

MMU기법

논리적 주소값에 base register의 값을 더해 물리적 주소를 얻어낸다.
기준 레지스터는 해당 프로세스의 메모리 시작 주소를 가지고 있다.
프로그램의 주소 공간이 물리적 메모리의 한 장소에 연속적으로 적재되는 것으로 가정한다.
문맥 교환으로 CPU에서 수행중인 프로세스가 바뀔 때마다 재배치 레지스터의 값을 해당 프로세스에 해당하는 값으로 재설정	
--------------------나동빈 강의를 들어보자!! 

운영체제의 목적
사용자가 컴퓨터를 편리하게 사용하는것
컴퓨터 하드웨어가 효율적으로 사용되는것(자원이 효율적으로 사용!)


밑) 하드웨어 ->운영체제->어플리케이션->사용자  (위

1)일괄처리시스템
특징: 유사한 요구를 가지는 작업을 함꼐 모아
단점: 계속 쉬는 상태

2)다중시스템 프로그램 
하나를 선택해서 차례대로 쉴때마다 다음프로그램 다음프로그램!! 
모든프로그램이 전부 쉬는상태가 아닌이상 계속 시피우한테 일을 시킬 수 있음 

3)시분할시스템 
다중프로그램의 장점을 체택하여 확장한 시스템
우리가 느끼지못할정도로 짧게 따닥따닥따딱 그래서 동시에 작동을 하고있는 것처럼 느낌!!

작업스케줄링 - 보조기억장치에 프로그램이 저장되어있고 그 일부를 선택해서 메모리에 적재하는 전략
CPU스케줄링 - 메모리에 올라온 작업들 중에서 무엇부터 실행할지 고르는 전략
일괄처리 시스템- 상호작용이 필요없는 큰 단위의 작업들을 수행할 때 사용됩니다 

* 다중처리시스템 : 여러개의 CPU
대칭적 다중처리 시스템 : 상호보조 우선순위 노노 
비대칭적 다중 처리 시스템 : 각 치리기 마다 특정 작업이 정해져있음 우선순위 정해져있음 

* 분산처리 시스템 : 네트워크를 이용해서 도잇에 작업을 처리하는 시스템 각각 씨피유들은 메모리를 공유하지않음  
ex) 클라이언트 서버 시스템 네이버 로그인같은거 있음 ㅇㅇ 웹사이트와 접속자 사이의 관계를 이야기 할 수 있음
 -피투피시스템 : 각 컴퓨터가 서버이자 클라이언트가 되는 시스템으로서 대표적인 예시로 토렌트 서비스가 있습니다.

*클러스터 시스템 : 물리적으로 많은 CPU를 한 곳에 모아서 특정한 작업을 수행하는 시스템 
LAN으로 서로 연결된 각각의 CPU는 다른 CPU와 상호작용하여 고속처리 시스템을 지원하게 됩니다. 

- 대칭적 클러스터 시스템 : 각각의 씨피유가 호스트가 되어 서로를 관리하는 구조로 둘이 상의 작업을 수행할 수 있음
- 비대칭적 클러스터 시스템 : 호스트 씨피유가 다른 씨피유를 관리하면서 특정한 씨피유가 작동을 중지하면 호스트 씨피유가 작업을 돕는 구조 

* 실시간 시스템 :의학영상시스템 무시시스ㅔㅁ같이 즉시처리를 요할때 채택되는 시스템
- 연성실시간 시스템  (소프트) 우선순위를 가지고 빠르게 게산되긴하지만 시간만을 중요히장ㄶ는 시슨템
빠른시간이 절대적으로 요구되는 시스템 단기메모리만 써서 시건엄수를최우선적으로!! 

-----------------------------------컴퓨터의 작동과정
**컴퓨터 부팅 과정
- 전원이 켜질때 ROM에 저장된 초기 프로그램을 실행합니다
- 초기 프로그램은 메모리, 씨피유 , 레지스터 등을 초기화 시킵니다
- 이휴 운영체제를 찾아서 메모리에 적재합니다
- 운영체제는 첫번째 프로세스를 즉시 실행합니다
- 인터럽트가 발생하면서 씨피유가 각종 작업을 처리합니다
 
* 하드 웨어와 소프트웨어는 모드 씨피유에 인터럽트를 발생시킬 수 있습니다.
일반적으로 인터럽트는 입출력 연산이 종료되었을때, 예외가 발생하였을때, 운영체제의 다양한 서비스를 욕할 때 등 다양한 이윯 발생할 수 있습니다

* 인터럽트가 발생하였을 때 씨피유는 현재 하던일을 중단하고 , 그 인터럽트에 대한 처리를 먼저 하게 됩니다 
그러한 처리를 서비스 루틴이라고하며 일반적으로 운영체제가 이를 처리하니다 
서비스루틴이 종료되면 다시 씨피유는 인터럽트 되었던 연산을 재개합니다.

인터럽트를 해결하는 방법 
1 운영체제가 어떤 종류의 인터럽트인지 확인하고 해당 인터럽트 핸들러를 호출하여 인터럽트를 처리합니댜 (메모리부하 짜장많음)
2 인터럽트가 요청되면 인터럽트 서비스루틴(따로 하드웨어나 SSD가 갖고있음)의 주소를 가리키는 포인터들로 구성된 인터럽트 벡터테이블을 참조합니다
 참조된 포인터가 가리치는인터럽트 처리루틴을 호출하여 인터럽트를처리합니다
 
>> 최그에는 방법 2를 채택하는 운영체제가 많습니다. 인터럽트가 발생하면 os는 하던일에대한 정보를 저장하고 중단합니다. 
인터럽트 벡터로 제어를 옮겨 요쳥한 인터럽트 처리루틴의 주소르 ㄹ가리키는 포인터를 참조합니다 
포인터를 따라 이동하며 인터럽트 처리 루틴을 완료한 후에 다시 하던일로 돌아갑니다
>> 인터럽트가 실행되고 있을때 다른 인터럽트가 또 발생하는 경우에는 다른 인터럽트를 대기시킵니다 대기릴 시키는 이유는 데이터 소실을 막기위ㅎㅁ입니다.
또한 인터럽트 사이에는 우선순위가 있어서 우선순위에 따라 인터럽트 처리순서를 조절합니다.
 
----------------입출력시스템
-입력시스템
씨피유가 장치제어기의 레지스터에 명령을 적재합니다
장치제어기는 레지스터의 내용을 조사하여 수행할 동작을 검사합니다
레지스터 내용이 읽기 명령이므로 입력장치에 읽기 신호를 보냅니다
입력장치는 데이터를 읽어 버퍼에 저장합니다
제어부분은 씨피유에 인터럽트를 발생시킵니다
씨피유가 버퍼에서 데이터를 읽어들이고 입력을 완료합니다.

장치제어기 : 공통버스와 장치사이에 위치하며 장치를 제어하는 역할 
장치제어기는 내부적으로 저장장치를 가지고 있을 수 있으며 자신의 주변장치와 데이터 송수신을 할 수 ㅣㅇㅆ도록 인터페이스 여갈을 합니다
ㄷ
동기식 입출력 : 입출력이 시작되고 입출력이 끝난 후에 제어가 사용자 프로세스로 복귀하는 구조
매순간마다 수행해야 할 입출력 요청은 하나가 되므로 운영체제는 어느 장치가 인터럽트를 호출하고 있는지 알고있습니다
다만 여러장치에서 동시에 입출력이 불가능하며 각종 유영한 연산들이 병행실행될 가능성을 완전히 배제합니다

비동기식 입출력 :  입출력이 실행되고 끝나기 전에 사용자 프로그램으로 제어가 되어 돌아갑니다. 
씨피유가 하나의 요청을 보낸다음 인터럽트가 돌아오기 전까지 다른일을 계속 수행할 수 있습니다.
다만 이 경우 입출력 장치 별도로 장치의 종류 주소 상태 등의 정보를 매 순간 저장하여 관리할 피료악 있씁니다
이런 정보는 장치 상태 테이블의 ㅕㅇ태로 저장되 ㅓ관리합니다.
또한 다른 프로세스들이 끝은 장치에 대해 요청을할 수 ㅣㅇㅆ기 떄문에 
운영체제는 매 장치를위해서 대기 큐를 유지해얗바니다
하나의 입출력이 실행되는 동안에도 다른 시스템 작업들을 병행할 수 ㅣㅇㅆ다는 점에서 효율성 증가

DMA  
데이터를 낱개가 아니라 블록단위로 전송하는 효율적인 방식 중 하나 

DMA 입출력 방식의 작동과정
운영체제가 입출력 요청을 보냅니다
디엠에이 제어기의 레지스터에 주소와 전송길이가 저장됩니다
디엠에이 제어기느 한 블록의 입출력 동작을 수행하고 한동안 씨피유는 다른작업을 합니다 
입출력 동작이 완료되면 디엠에이 제어기는 씨피유에게 완료했다는 인터럽트를 보냅니다.

----------------저장장치구조 

하나의 명령이 실행하는 싸이클!!
기억장치로부터 명령을 인출해서 씨피유 내부의 명령레지스터에 저장합니다
씨피유가 명령을 해독하빈다
피연산자를 씨피유 내부의 레지스터에 저장합니다
명령을 실행합니다 
결과를 기억장치에 저장합니다
 



